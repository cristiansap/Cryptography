from Crypto.Util.number import bytes_to_long, getPrime
from secret import flag

p, q = getPrime(512), getPrime(512)
n = p*q
print(n)
e = 60016485563460433620911462871489753027091796150597697863772440338904706321535832359517415034149374289955681381097544059467926029963755494161141305994584249448583991034102694954139120453335603006006970009433124857766494518747385902016093339683987307620366742481560543776055295663835860818720290861634213881385
m = bytes_to_long(flag.encode())
print(pow(m, e, n))

# OUTPUT:
# 138728501052719695830997827983870257879591108626209095010716818754108501959050430927220695106906763908822395818876460759364322997020222845247478635848425558793671347756842735011885094468024344931360037542098264527076663690119553302046205282212602106990248442514444587909723612295871002063257141634196430659767
# 40254592670056897412607628206293101688805220813070436291135637864728213056255791064749974976546612178688674369066366922740751516162695397004586912385306024596939610039396946106249406597089442755317018963104229975283670995939592563335766562761230485826833361814955946571348001305529987233069227384314146133493


# NOTE_1: Bonet-Durfee is suitable for this case because it allows to recover the private key 'd' in RSA when d < N^delta, for some delta < 0.292 
#         In this case, an hint that could lead to use Boneh-Durfee is that the modulus N is very big, meaning that:
#         1) I cannot factorize N   => factorDB and Fermat's factorization excluded
#         2) I do not have access to an Oracle   => Padding Oracle Attack excluded
#         3) 'e' is extremely huge, so I cannot use Low public exponent
#         4) Even though Wiener's works under the same condition of Boneh-Durfee ('d' is "small"), the fact that 'e' is extremely huge does not help this algorithm to work

# NOTE_2:
# Use SAGE to run the Boneh-Durfee attack:
# sage /Users/cristiansapia/Desktop/Cryptography/Python/asymmetric/rsa_level_9/rsa_level_9.py